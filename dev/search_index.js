var documenterSearchIndex = {"docs":
[{"location":"ref/transport/#Transport-Families","page":"Transport","title":"Transport Families","text":"","category":"section"},{"location":"ref/transport/","page":"Transport","title":"Transport","text":"In order to encode the general algorithm provided","category":"page"},{"location":"mathematical_details/#Mathematical-Details","page":"Mathematical Details","title":"Mathematical Details","text":"","category":"section"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"This library is entirely focused on implementing the transport map accelerated Markov chain Monte Carlo inference algorithm discussed in the following paper.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Parno, Matthew D., and Youssef M., Marzouk. \"Transport Map Accelerated Markov Chain Monte Carlo\". SIAM/ASA Journal on Uncertainty Quantification 6, no.2 (2018): 645-682. SIAM Link, arXiv Link.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"In summary, this is an inference algorithm which samples a posterior distribution mu_theta by simultaneously finding a map T which transports said distribution to a reference standard Gaussian mu_r = T_ mu_theta and performing Metropolis-Hastings in this reference space. The proceeding subsections will describe the objects at play.","category":"page"},{"location":"mathematical_details/#Transport-maps","page":"Mathematical Details","title":"Transport maps","text":"","category":"section"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Suppose we have some distribution mu_theta with density pi with respect to the Lebesgue measure on mathbb R^d.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"displaystyle mu_theta(rm dtheta) = pi(theta) rm dtheta","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Provided a measurable map T mathbb R^d rightarrow mathbb R^d, we may transport mu_theta to another distribution T_mu_theta, defined to act on measurable functions f mathbb R^d rightarrow mathbb R like so.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"displaystyle int f(r) T_mu_theta(rm dr) = int fbig(T(theta)big) mu_theta(rm dtheta)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"note: Note\nFrom a Monte Carlo perspective, a sample r sim T_mu_theta is equivalent to sampling theta sim mu_theta and taking r = T(theta) (hence the phrase Transport).","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"If our density pi is continuous and T is a continuously differentiable bijection, the change of variables theorem from calculus tells us that the transport distribution (let's denote this mu_r = T_mu_theta) will have the following density p.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"p(r) = pibig(T^-1(r)big) bigdet nabla T^-1(r)big 1em\ndisplaystyleint f(r) mu_r(rm dr) = int f(r) pibig(T^-1(r)big) big det nabla T^-1(r) big rm dr","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Above and throughout, nabla G denotes the Jacobian matrix of a map G mathbb R^d rightarrow mathbb R^d. From the perspective of the Gen ecosystem, if an address :theta is intended to encode samples of mu_theta, then one can subsequently encode samples of mu_r = T_astmu_theta to an address :r with the Trace Transform DSL.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"The paper above concerns itself with finding a transport map (referred to as the Knothe-Rosenblatt rearrangement) T mathbb R^d rightarrow mathbb R^d such that nabla T is lower-triangular and mu_r = T_mu_theta is the standard Gaussian measure on mathbb R^d. The lower-triangular property of nabla T is equivalent to T having the following structure.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"T(theta_1 ldots theta_d) = Big( T_1(theta_1) T_2(theta_1 theta_2) ldots T_d(theta_1 ldots theta_d) Big)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Such a structure is computationally advantageous, as the inverse image T^-1(r) and Jacobian determinant det nabla T(theta) are easy to evaluate. Also, the Gaussian nature of mu_r = T_mu_theta means that sampling theta sim mu_theta is as easy as sampling from standard Gaussian r sim mu_r and evaluating theta = T^-1(r). Hence, having such a map T, or a nice approximation thereof, means we may efficiently sample complicated posterior distributions mu_theta; such an algorithm is apt for systems like Gen.","category":"page"},{"location":"mathematical_details/#Approximating-transport-maps","page":"Mathematical Details","title":"Approximating transport maps","text":"","category":"section"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"In practice, it is infeasible to actually get the transport constraint T_mu_theta = mu_r for a standard Gaussian mu_r. Thus, for a fixed distribution mu_theta and proposed transport map tilde T, it is imperative to measure the discrepancy of our transport from the standard Gaussian. In other words, we want to measure the effectiveness of the following approximation.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"tilde T_mu_theta approx mu_r","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"One solution to this is to recognize that the true constraint tilde T_mu_theta = mu_r is equivalent to tilde T^-1_mu_r = mu_theta; this way, we may consider the discrepancy of an equivalent approximation.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"mu_theta approx tilde T_^-1mu_r","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Denoting tildepi as the density of tilde T_^-1mu_r, we have","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"tildepi(theta) = pbig(tilde T(theta)big) bigdetnablatilde T(theta)big","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"From here, we may measure the discrepancy between mu_theta and tilde T_^-1mu_r with the Kullback-Leibler divergence.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"beginaligned\n  D_KLbig( mu_theta parallel tilde T_^-1mu_r big)\n  = int logBig(fractildepi(theta)pi(theta)Big) mu_theta(rm dtheta) \n  = int logpi(theta) mu_theta(rm dtheta) + int Big( - log pbig(tilde T(theta)big) - logbigdetnablatilde T(theta)big Big) mu_theta(rm dtheta)\nendaligned","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"This divergence is minimized when our transport constraint is exact, and so finding the true transport T is equivalent to solving the following optimization problem over the set mathcal T of lower-triangular continuously differentiable bijections.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"T = argmin_tilde T in mathcal T int Big( - log pbig(tilde T(theta)big) - logbigdetnablatilde T(theta)big Big) mu_theta(rm dtheta)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"If provided samples theta^(1) ldots theta^(K) from mu_theta, we may approximate the integral above as follows.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"beginaligned\n  int Big( - log pbig(tilde T(theta)big) - logbigdetnablatilde T(theta)big Big) mu_theta(rm dtheta) \n  quadapprox K^-1sum_k=1^K Big( -log pbig(tilde T(theta^(k))big) - logbigdetnablatilde T(theta^(k))big Big) \n  quad= K^-1sum_k=1^K Big( fracn2log(2pi) + frac12sum_i=1^d tilde T_i^2(theta) - sum_i=1^d logfracpartial tilde T_ipartial theta_i(theta^(k)) Big) \n  quad= fracn2log(2pi) + K^-1 sum_i=1^d sum_k=1^K Big( frac12tilde T_i^2(theta) - logfracpartialtilde T_ipartial theta_i(theta^(k)) Big)\nendaligned","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Note that the first equality above is utilizing the closed form of the standard Gaussian density p and the lower-triangular structure of nablatilde T(theta). With this approximation, we choose to instead minimize the following objective function.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"C(tilde T) = sum_i=1^dsum_k=1^K Big(frac12 tilde T_i^2(theta) - logfracpartialtilde T_ipartialtheta_i(theta^(k)) Big)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"From here, we may reduce the optimization problem from the large space mathcal T to a parameterized set of maps T(cdot gamma)_gamma in mathcal A where mathcal A is some nice parameter set. In particular, for each i=1ldots d, we may pick a finite ordered basis of functions (psi_j)_jinmathcal J_i and declare our map parameterization so that our parameter set is mathcal A = prod_i=1^d mathbb R^mathcal J_i and the components of the map T(cdot gamma) are as follows.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"tilde T_i(theta gamma_i) = sum_jinmathcal J_i gamma_ij psi_j(theta)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"This linear form makes optimizing Cbig(tilde T(cdotgamma)big) simpler.","category":"page"},{"location":"mathematical_details/#Map-based-Markov-chain-Monte-Carlo","page":"Mathematical Details","title":"Map-based Markov chain Monte Carlo","text":"","category":"section"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Provided a complicated posterior distribution mu_theta and a transport map tilde T such that tilde T_mu_theta is approximately Guassian, we may choose to perform the Metropolis-Hastings algorithm on either of mu_theta or tilde T_mu_theta and subsequently map samples via tilde T. Because tilde T_mu_theta is approximately Gaussian, our proposals do not need to account for complicated features of the distribution, as they would for mu_theta.  To this end, the map tilde T is accounting for these complicated features.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"For a fixed proposal kernel Q_r with density q_r","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Q_r(rm dr  r) = q_r(r  r) rm dr","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"the induced tilde T-pullback kernel Q_theta=tilde T^-1_Q_r, characterized to satisfy the following for all measurable f","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"displaystyleint f(theta) Q_thetabig(rm dtheta  theta big) = int f(r) Q_rbig(rm dr  tilde T(theta) big)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"can be evaluated as follows.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Q_thetabig(rm dtheta  theta big) = q_rbig( tilde T(theta)  tilde T(theta) big) bigdetnablatilde T(theta)big rm dtheta","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Performing Metropolis-Hastings for mu_theta associated to proposal Q_theta now amounts to the following algorithm.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"Get reference r = tilde T(theta)\nSample proposal r sim Q_r(cdot  r)\nSolve target theta = tilde T^-1(r)\nPerform accept-reject step with acceptance probability alpha","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"alpha = minBig 1 fracpi(theta)q_rbig(tilde T(theta)  tilde T(theta) big)bigdetnablatilde T(theta)bigpi(theta)q_rbig(tilde T(theta)  tilde T(theta) big)bigdetnablatilde T(theta)big Big","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"If Q_r is a derivative-based proposal, we can get the gradient of the density tilde p for distribution tilde T_mu_theta by recognizing","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"logtilde p(r) = logpibig(tilde T ^-1(r)big) + sum_i=1^n logfracpartialtilde T_i^-1partial r_i(r)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"and so the chain-rule gives us","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"nabla_theta logtilde pbig( tilde T(theta) big) = nabla logpi(theta) - sum_i=1^n frace_i^T Htilde T(theta)fracpartial tilde T_ipartial theta_i(theta)","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"where Htilde T(theta) is the Hessian matrix associated to tilde T at theta.","category":"page"},{"location":"mathematical_details/#Adaptive-transport-map-Markov-chain-Monte-Carlo","page":"Mathematical Details","title":"Adaptive transport map Markov chain Monte Carlo","text":"","category":"section"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"The algorithm now amounts to performing Metropolis-Hastings with a transport map tilde T(cdot gamma) to produce samples of mu_theta and adaptively updating the transport map tilde T(cdot gamma) leadsto tilde T(cdot gamma) from said samples. Below is pseudocode for implementing the algorithm.","category":"page"},{"location":"mathematical_details/","page":"Mathematical Details","title":"Mathematical Details","text":"<div class=\"admonition is-info\">\n  <header class=\"admonition-header\">Transport map accelerated Monte Carlo</header>\n  <div style=\"display: flex; flex-direction: column; margin: 0 1em 0.5em 1em\">\n    <div style=\"display: flex; margin: 0.5em 0 0.5em 0.5em\">\n      <em style=\"margin-right: 1em\">Input.</em>\n      <span>Initial state $\\theta_0$, inital vector of transport map parameters $\\overline \\gamma_0 \\in \\mathcal A$, reference proposal $Q_r$, number of steps $K_U$ between map adaptations, total number of steps $L$.<span>\n    </div>\n    <div style=\"display: flex; margin: 0.5em 0 0.5em 0.5em\">\n      <em style=\"margin-right: 1em\">Output.</em>\n      <span>MCMC samples $\\{\\theta^{(1)}, \\ldots, \\theta^{(L)}\\}$ of the target distribution $\\mu_\\theta$.</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>1</strong></tt>\n      <span>Set state $\\theta^{(1)} = \\theta_0$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>2</strong></tt>\n      <span>Set parameters $\\overline\\gamma^{(1)} = \\overline\\gamma_0$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>3</strong></tt>\n      <span><strong style=\"margin-right: 0.5em\">for</strong>$k \\leftarrow 1 \\ldots L-1$<strong style=\"margin-left: 0.5em\">do</strong></span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>4</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Compute the reference state, $r^{(k)} = \\tilde T(\\theta^{(k)}; \\overline \\gamma^{(k)})$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>5</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Sample the reference proposal $r' \\sim Q_r(\\cdot|r^{(k)})$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>6</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Compute the target proposal sample, $\\theta' = \\tilde T^{-1}(r'; \\overline \\gamma^{(k)})$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>7</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>\n        Calculate the acceptance probability:\n        \\[ \\alpha = \\min\\Big\\{  1, \\frac{\\pi(\\theta')q_r\\big(r^{(k)} | r' \\big)\\big|\\det\\nabla\\tilde T(\\theta^{(k)})\\big|}{\\pi(\\theta)q_r\\big(r' | \\tilde r^{(k)} \\big)\\big|\\det\\nabla\\tilde T(\\theta')\\big|}\\Big\\} \\]\n      </span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>8</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Set $\\theta^{(k+1)}$ to $\\theta'$ with probability $\\alpha$; else set $\\theta^{(k+1)}$ to $\\theta^{(k)}$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>9</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span><strong style=\"margin-right: 0.5em\">if</strong>$(k \\mod K_U) = 0$<strong style=\"margin-left: 0.5em\">then</strong></span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>10</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span><strong style=\"margin-right: 0.5em\">for</strong>$i \\leftarrow 1\\ldots d$<strong style=\"margin-left: 0.5em\">do</strong></span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>11</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Update $\\overline \\gamma_i^{(k+1)}$ by optimizing $\\gamma \\rightarrow \\tilde C\\big(\\tilde T(\\cdot; \\gamma)\\big)$ for samples $\\{\\theta^{(1)},\\ldots,\\theta^{(k)}\\}$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>12</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span><strong style=\"margin-right: 0.5em\">else</strong></span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>13</strong></tt>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span style=\"margin: 0 1em 0 0.5em; border-left: 1px solid black\"></span>\n      <span>Keep $\\overline \\gamma^{(k+1)} = \\overline \\gamma^{(k)}$</span>\n    </div>\n    <div style=\"display: flex\">\n      <tt style=\"width: 1.5em; text-align: right; margin-right: 1em;\"><strong>14</strong></tt>\n      <span><strong style=\"margin-right:1em\">return</strong> $\\{\\theta^{(1)},\\ldots,\\theta^{(L)}\\}$</span>\n    </div>\n  </div>\n</div>","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The package may be installed using the Julia package manager like so.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"pkg> add https://github.com/mvarble/gen-transport-mcmc","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"From here, one may use the GenTransportMCMC module like in the example below.","category":"page"},{"location":"getting_started/#Example","page":"Getting Started","title":"Example","text":"","category":"section"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"T(theta gamma) = ","category":"page"},{"location":"#GenTransportMCMC.jl","page":"Home","title":"GenTransportMCMC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a transport map accelerated Markov chain Monte Carlo [1] inference algorithm for Gen.jl systems. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Parno, Matthew D., and Youssef M., Marzouk. \"Transport Map Accelerated Markov Chain Monte Carlo\". SIAM/ASA Journal on Uncertainty Quantification 6, no.2 (2018): 645-682. SIAM Link, arXiv Link.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting_started.md\",\n  \"mathematical_details.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reference","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"ref/transport.md\",\n]\nDepth=2","category":"page"}]
}
